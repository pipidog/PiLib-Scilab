// **** Purpose ****
// This code generates the <n(R=0)|H|m(R)> matrix using the lat and hop
// results. This output format is particular useful to implement TB. 
// **** Variables ****
// [lat]: structure 
// <= variable generated by lat
// [hop]: structure
// <= variable generated by lat
// [uc_index]: nx3, integer
// => the order and index of R in terms of lattice vectors
// [H_R]: tot_state x tot_state x lengt(uc_index(:,1))
// => the <n(R=0)|H|m(R)> matrix   
// **** Version ****
// 02/16/2016: first built
// **** Comment ****
// H_local=hop.onsite_E+hop.LS_mat+scc.U_mat

function [uc_index,H_R]=PIL_H_R(surr_site,state_info,H_local,hop_mat)
    tot_sublat=size(surr_site);
    tot_state=length(state_info(:,1));
    
    [lhr,rhs]=argn()
    if rhs==5
        U_mat=zeros(tot_state,tot_state);
    end
    
    // setup sublattice state correspondence
    site_range=zeros(tot_sublat,2);
    for n=1:tot_sublat
        tmp=find(round(state_info(:,2))==n);
        site_range(n,1)=min(tmp);
        site_range(n,2)=max(tmp);
    end
    
    // construct H_R
    uc_index=[0,0,0]
    H_R=zeros(tot_state,tot_state,1)
    for n=1:tot_sublat
        for m=2:length(surr_site(n)(:,1))
            tmp=PIL_row_find(uc_index,surr_site(n)(m,4:6))
            if tmp==[] then
                uc_index=cat(1,uc_index,surr_site(n)(m,4:6));
                uc_id=length(uc_index(:,1));
                H_R(:,:,uc_id)=zeros(H_R(:,:,uc_id-1))
            else
                uc_id=tmp;
            end
            s1=round(surr_site(n)(1,3));
            s2=round(surr_site(n)(m,3));
            r1=site_range(s1,1);
            r2=site_range(s1,2);
            c1=site_range(s2,1);
            c2=site_range(s2,2);
            H_R(r1:r2,c1:c2,uc_id)=..
            H_R(r1:r2,c1:c2,uc_id)+hop_mat(s1)(r1:r2,c1:c2,m-1);
        end
    end
    H_R(:,:,1)=squeeze(H_R(:,:,1))+H_local;
endfunction
