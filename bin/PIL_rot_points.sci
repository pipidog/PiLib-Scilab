// **** Purpose ****
// For two cartisian basis {x1,y1,z1} and {x2,y2,z2}. Their transformation
// matrix can be generated by giving three equivalent points. These three
// points will defined a plane. This code will generate a rotation matrix
// to connect the two coordinate, so the representation of the three points
// will be identical. 
// **** Variables ****
// [pt1]: 3x3, real
// <= three points in coordinate-1. Positions should written in column form.
// [pt2]: 3x3, real
// <= three points in coordinate-2. Positions should written in column form.
//    these points must be ordered as their equivalent ones in points1.
// [criterion]: 1x2, real, optional, default:[0.5 angstrom, 3.0 degree]
// <= criterion for successful rotation on bond length and angle
// [M]: 3x3, real
// => the rotation matrix that makes M*V1=V2 
// [V_shift]: 3x1, real
// => the shift vector of two coordinate. 
// [str_diff]: 2x3, real
// => the structure difference between v21, v31, v21 and p21, p31, p23.
//    [L_diff;ang_diff] if bond length difference > 0.5 or angle differneces 
//    are greater than 3.0 degree, M is considered failed.
//    If so, check if the three points are real equivalent. 
// **** Version ****
// 01/22/2016 first built
// **** Comment ****
// 1. Algorithm:
//   1). Shift pt1, so that pt1(1,:)=pt2(1,:). Now all pt1 is defined
//       in this shifted coordinate.
//   2). Define V21=pt1(2,:)-pt1(1,:); V31=pt1(3,:)-pt1(1,:)
//              P21=pt2(2,:)-pt2(1,:); P31=pt2(3,:)-pt2(1,:)
//       and their unit vectors v21, v31, p21, p31. 
//   3). rotate along (v21+p21)/2 by %pi, get M1, so M1*v21 --> p21
//   4). rotate along p21 with appropriate angle phi, get M2,
//       so M2*M1(v31')=p31' and M2*M1*(v21')=M1*v21'=p21'.
//   5). If so, M=M2*M1, V_shift=pt2(1,:)-pt1(1,:).
//       All points in pt1: M*(pt1+V_shift)'=pt2'.
//       i.e M*(A1+V_shift)=A2
function [M,V_shift,str_diff]=PIL_rot_points(pt1,pt2,criterion)
    [lhr,rhs]=argn()
    if rhs==2 then
        criterion=[0.5,3.0]
    end
    
    // check input points form identical triangles
    L12_1=norm(pt1(2,:)-pt1(1,:));
    L12_2=norm(pt2(2,:)-pt2(1,:));
    L13_1=norm(pt1(3,:)-pt1(1,:));
    L13_2=norm(pt2(3,:)-pt2(1,:));
    L23_1=norm(pt1(3,:)-pt1(2,:));
    L23_2=norm(pt2(3,:)-pt2(2,:));
    L_diff=[(L12_1-L12_2),(L13_1-L13_2),(L23_1-L23_2)];
    if max(abs(L_diff)) > criterion(1) then
        disp('Error: PIL_rot_points, bond length not match!');
        disp(cat(2,'L_diff=',string(L_diff)));
        abort
    end
    
    // shift pt1 coordinate
    pt1_backup=pt1;
    V_shift=pt2(1,:)-pt1(1,:);
    pt1=pt1+repmat(V_shift,3,1);
    
    // rotate along (v21+p21)/2
    v21=pt1(2,:)-pt1(1,:);  v21=v21/norm(v21);
    p21=pt2(2,:)-pt2(1,:);  p21=p21/norm(p21);
    
    u=(v21+p21); u=u/norm(u);
    M1=PIL_rot_axis(u,%pi);
    
    // rotate along p21
    for n=1:3
        pt1(n,:)=(M1*pt1(n,:)')'
    end
    u=p21;
    v31=pt1(3,:)-pt1(1,:); v31=v31/norm(v31);
    p31=pt2(3,:)-pt2(1,:); p31=p31/norm(p31);

    v31_plane=(v31-(v31*u')*v31); v31_plane=v31_plane/norm(v31_plane);
    p31_plane=(p31-(p31*u')*p31); p31_plane=p31_plane/norm(p31_plane);

    phi=acos(v31_plane*p31_plane');
    M2=PIL_rot_axis(u,phi); 

    M=M2*M1
    
    // calculate angle differences
    pt1_tmp=pt1_backup+repmat(V_shift,3,1)
    for n=1:3
        pt1_tmp(n,:)=(M*pt1_tmp(n,:)')'
    end
    v21=pt1_tmp(2,:)-pt1_tmp(1,:); v21=v21/norm(v21);
    v31=pt1_tmp(3,:)-pt1_tmp(1,:); v31=v31/norm(v31);
    v23=pt1_tmp(2,:)-pt1_tmp(3,:); v23=v23/norm(v23);
    p23=pt1_tmp(2,:)-pt1_tmp(3,:); p23=p23/norm(p23);
    ang_diff=acos([v21*p21',v31*p31',v23*p23'])/%pi*180
    
    if max(abs(imag(ang_diff)))>1e-4 | abs(max(real(ang_diff)))>= criterion(2) then
        disp('Error: PIL_rot_points, rotation matrix failed!')
        disp(cat(2,'Angle Difference=',string(ang_diff)))
    else
        ang_diff=real(ang_diff);
    end   
    str_diff=[L_diff;ang_diff]
endfunction


