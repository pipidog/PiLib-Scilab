// **** Purpose ****
// This code calculates the Chern number of the given Floquet system
// generated by PiLab.
// **** Variables ****
// [lat],[hop],[scc],[flq]: structues
// <= the output of lat, hop, scc, flq in PiLab
//    if Chern, let [flq]=[], if F-Chern, let [hop]=[] & [scc]=[] 
// [b_mesh]: 1x2, int
// <= mesh of the BZ. eg.[5,5] means you mesh the whole BZ from
//    [-%pi,%pi] into 11x11. (always odd to include TRIM, though,
//    it is not necessary. But it makes this code consistent with
//    Z2 definition)
// [occ_band}: 1x1, int
// <= how many occupied bands below Ef
// [k_diff]: 1x2, real
// <= k_diff to aviod divergence in U1 link
// [Chern_val]: tot_band x 1, int
// => The Chern number of each band, must be an integer 
// [Fk_field]: tot_state x tot_mesh points, real
// => The F_field/(2*%pi*%i) of each band at each k-point
// **** Version ****
// 11/24/2014 first version
// 12/02/2014 separate to independent function from PiLab_flq_chn
// 04/13/2015 change to use non-Abelian Berry connection formulation
// 06/06/2015 combine Chern and Floquet Chern
// **** Comment ****
// These formulas can be found in JPSJ 74 1674 (2005)

function [BZ_point,Chern_val,Fk_field]=PIL_Chern_cal(lat,hop,scc,flq...
    ,b_mesh,occ_band,k_diff)
    // check task type =================================================
    if flq==[] & hop~=[] & scc~=[] then // hop
        task=1 
    elseif flq~=[] & hop==[] & scc==[]  // flq
        task=2 
    else 
        disp('Error: PIL_Chern_cal, task cannot be specified!');
    end
    
    // check variables =================================================
    if length(lat.Primitive(:,1))~=2 then
        disp('Error: PIL_Chern_cal, system must be two dimension!');
    end
    if length(k_diff)~=2 then
        disp('Error: PIL_Chern_cal, k_diff must be two dimension!');
    end
    
    // define parameters ===============================================
    ieee(2); // change error message of inf & nan to warning only
    b_vec=PIL_vec_3d(lat.recip_vec);
    k_diff=(1e-6)*PIL_vec_3d(k_diff); // arbitary k_diff
    tot_k=prod(2*b_mesh+1);
    select task
    case 1
       tot_state=length(hop.state_info(:,1));
    case 2
       tot_state=length(flq.state_info(:,1));
    end
    
    // k-point classification ==========================================
    // generate all k-points
    // k_point=[kx,ky,kz,j1,j2,k+1,k+2] 
    k_point=zeros(tot_k,7);
    count=0;
    for n1=1:2*b_mesh(1)+1
        for n2=1:2*b_mesh(2)+1
            count=count+1;
            j1=((n1-1)/(2*b_mesh(1)))-(1/2);
            j2=((n2-1)/(2*b_mesh(2)))-(1/2);
            k_point(count,1:3)=j1*b_vec(1,:)+j2*b_vec(2,:);
            k_point(count,4:5)=[j1,j2];
            if k_point(count,4)~=1/2
                k_point(count,6)=count+2*b_mesh(2)+1;
            end
            if k_point(count,5)~=1/2
                k_point(count,7)=count+1;
            end       
        end
    end
    // extract BZ
    B_zone=find(k_point(:,4)~=0.5 & k_point(:,5)~=0.5);
    tot_BZ=length(B_zone);
    BZ_point=k_point(B_zone,1:3);

    // calculate eigenvectors ==========================================
    k_band=zeros(tot_state,tot_k);
    k_vec=zeros(tot_state,tot_state,tot_k);

    // not boundary, B_zone
    for n=1:tot_BZ
        k_ind=B_zone(n);
        select task
        case 1
           Hk=PIL_Hk_gen(k_point(k_ind,1:3)+k_diff,lat.surr_site...
           ,hop.state_info,scc.H_onsite,hop.hop_mat,'full'); 
        case 2
           Hk=PIL_Hk_flq(k_point(k_ind,1:3)+k_diff,lat,flq,'full');
        end
        [V,D]=spec(Hk);
        k_band(:,k_ind)=diag(D);
        k_vec(:,:,k_ind)=V;
    end

    // boundary, BB_zone
    BB_zone=find(k_point(:,4)==0.5 | k_point(:,5)==0.5);
    for n=1:length(BB_zone)
        k_ind=BB_zone(n);
        k_pbc=0;
        if k_point(k_ind,4)==1/2 then
            k_pbc=PIL_row_find(k_point(:,4:5),[-1/2,k_point(k_ind,5)]);
        elseif k_point(k_ind,5)==1/2
            k_pbc=PIL_row_find(k_point(:,4:5),[k_point(k_ind,4),-1/2]);
        end
        k_band(:,k_ind)=k_band(:,k_pbc);
        k_vec(:,:,k_ind)=k_vec(:,:,k_pbc);
    end

    // Define all fields ===============================================
    function U_val=U_link(occ_band,basis_ind,k_ind)
        k_nu_ind=k_point(k_ind,5+basis_ind); 
        U_val=det(k_vec(:,1:occ_band,k_ind)'*k_vec(:,1:occ_band,k_nu_ind));
        U_val=U_val/abs(U_val);
        if isnan(U_val) | isinf(U_val) then
            disp('Error: PIL_Chern_cal, U_link diverges!');
            disp('       Please change k_diff!');
            abort;
        end 
    endfunction

    function F_val=F_field(occ_band,k_ind)
        k1_ind=k_point(k_ind,6);
        k2_ind=k_point(k_ind,7);
        F_val=log(U_link(occ_band,1,k_ind)*U_link(occ_band,2,k1_ind)...
        *inv(U_link(occ_band,1,k2_ind))*inv(U_link(occ_band,2,k_ind)));
        if abs(real(F_val)) >= 1e-5 then
            disp('Error: PIL_Chern_cal, F_val is not pure imaginary!');
            abort;
        else
            F_val=imag(F_val)
            // move to main branch
            F_val=F_val-(2*%pi)*round(F_val/(2*%pi));
            if abs(F_val+%pi) < 1e-6 then
                F_val=%pi;
            end
        end
    endfunction
    
    // calculate Chern number ==========================================
    Fk_field=zeros(tot_BZ,1);
    for n=1:tot_BZ
        k_ind=B_zone(n);
        Fk_field(n)=real(F_field(occ_band,k_ind)/(2*%pi));
    end
    Chern_val=sum(Fk_field);
    if PIL_equal(Chern_val,round(Chern_val)) then
        Chern_val=round(Chern_val)
    else
        disp('Error: PIL_Chern_cal, Chern_val is not an integer!');
        abort;
    end
endfunction

