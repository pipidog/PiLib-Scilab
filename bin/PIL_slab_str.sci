// **** Purpose ****
// 1. Use PIL_conv_cell to generate a conventional cell. So the new 
//    conventional cell will have a3 axis perpendicular to a2 and a1.
// 2. Use the output variables: cc_vec, cc_sublat as inputs, this 
//    function can constructure a slab sructure, i.e. the output 
//    structure has only fininte size on a3 axis. 
// **** Variables ****
// [cc_vec]: 3x3, real
// <= the lattice vectors of conventional cell genetated by PIL_conv_cell
// [cc_sublat]: nx10
// <= the sublattice information of conventional cell generated by 
//    PIL_conv_cell
// [tot_a3_cc]: 1x1, int
// <= how many conventional cell in the a3 direction. 
// [a3_range]: 1x2, real / []
// <= assign a3 range of the slab. if [], select all
// [vac_len]: 1x1, real / []
// <= enlarge the slab a3 vector to vac_len, so a vaccum zoen appears. 
//    Note that, the default slab_vec is always tot_a3_cc*cc_vec(3,:).
//    vac_len will be added based on this value. 
// [slab_vec]: 3x3, real 
// => lattice vectors of the slab structure. slab_vec(3,:) is supposed
//    the finite direction. 
//    default slab_vec is always tot_a3_cc*cc_vec(3,:) envn if you assign
//    a3_range.
// [slab_sublat]: nx6, real
// => sublattice information of the slab structure. 
//    [sublat index in prim cell, x,y,z, proj on a3, layer index]
// **** Version ****
// Jan 28, 2016: first built
// **** Comment ****
// see results using red_cart_conv.sce to output .xsf file. Then open 
// it by xcrysden. 

function [slab_vec,slab_sublat]=PIL_slab_str(cc_vec,cc_sublat,tot_a3_cc,a3_range,vac_len)
    select length(a3_range)
    case 0
    case 2
        a3_range=gsort(a3_range,'g','i');
    else
        disp('Error: PIL_slab_str, a3_range must be 2 values or []');
        abort
    end

    select length(vac_len)
    case 0
        vac_len=0;
    case 1
    else
        disp('Error: PIL_slab_str, vac_len must be 1 values or []');
        abort
    end

    // common variables
    tot_ccsub=length(cc_sublat(:,1));
    a3_unit=cc_vec(3,:)/norm(cc_vec(3,:));

    // construct slab strucutre
    // cc_sublat=[b,n1,n2,n3,x,y,z]
    // slab_sublat=[b, x,y,z, proj_on_a3]
    slab_sublat=zeros(tot_a3_cc*tot_ccsub,5)
    for n=1:tot_a3_cc
        slab_sublat((n-1)*tot_ccsub+1:n*tot_ccsub,1)..
        =cc_sublat(:,1);

        slab_sublat((n-1)*tot_ccsub+1:n*tot_ccsub,2:4)..
        =cc_sublat(:,5:7)+(n-1)*repmat(cc_vec(3,:),tot_ccsub,1);

        slab_sublat((n-1)*tot_ccsub+1:n*tot_ccsub,5)..
        =slab_sublat((n-1)*tot_ccsub+1:n*tot_ccsub,2:4)*a3_unit';
    end

    //construct sublatice of supercell select layers
    slab_vec=cc_vec;
    slab_vec(3,:)=cc_vec(3,:)*tot_a3_cc+vac_len*a3_unit;
    if a3_range~=[] then
        tmp=find(slab_sublat(:,5)>= a3_range(1) ..
        & slab_sublat(:,5)<= a3_range(2));
        slab_sublat=slab_sublat(tmp,:);
    end 
endfunction


//
//clear; clc; exec(PiLib);
//pc_vec=..
//[   6.300000    0.000000    0.000000
//4.440000    4.480000    0.000000
//-5.370000   -2.240000    2.430000]
//pc_sublat=..
//[  0.000000    0.000000    0.000000
//3.150000    0.000000    1.215000
//4.478580    1.868160    0.000000
//1.328580    1.868160    1.215000]
// cc_vec=[0 -1 -1; -1 0 -1; 1 1 0]
//[cc_sublat]=PIL_conv_cell_vec(pc_vec,pc_sublat,cc_vec)
//
// tot_a3_cc=5;
//[slab_vec,slab_sublat]=PIL_slab_str(cc_vec,cc_sublat,tot_a3_cc)
//
