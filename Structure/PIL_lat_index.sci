// **** Purpose ****
// given a position vector r, this code outputs the corresponding lattice 
// index based on the given lattice vector and sublatice  position. 
// **** Variables ****
// [r_in]: 1x3, real / 1x4 integer
// <= if r_in is a vector position [x,y,z], 
//    r_out is site index [sub_index,n1,n2,n3] and vice versa. 
//    All position vectros in row form.
// [lat_vec]: 3x3, real
// <= lattice row vectors
// [sublat]: nx3, real
// <= sublatice row positions in cartisian coordinate
// [dist_toler]: 1x1, real, optional , default=0.5 angstrom (w90)
// <= allowed length differnece between r_out and r_in  
// [sublat_list]: nx7, real, optional
// <= This variable can be generated by: PIL_sublat_list(lat_vec,sublat,1)
//    this variable is optional. However, input this variable prevent this
//    can calculate it repeatedly in loops. 
// [r_out]: 1x3 real, 1x4, integer
// => if r_in is a vector position [x,y,z], 
//    r_out is site index [sub_index,n1,n2,n3] and vice versa.
//    All position vectros in row form.
// [norm_err]: 
// => the length difference between r_in and r_out
// **** Version ****
// 01/25/2016: first built
// **** Comment ****
//
function [r_out,norm_err]=PIL_lat_index(r_in,lat_vec,sublat,dist_toler,sublat_list)
    // check variables
    if length(sublat(1,:))~=3 | length(lat_vec(1,:))~=3 then
        disp('Error: PIL_lat_index, sublat or lat_vec size are wrong!');
        abort
    end
    select length(r_in)
    case 3 // r_out=site_index
        [lhs,rhs]=argn();
        select rhs
        case 3 
            dist_toler=[];
            sublat_list=PIL_sublat_list(lat_vec,sublat,1);
        case 4
            sublat_list=PIL_sublat_list(lat_vec,sublat,1);
        end        
        tot_list=length(sublat_list(:,1));
        tot_sublat=length(sublat(:,1));

        r_uc=round((PIL_linexpan(r_in,lat_vec')))'
        sublat_list(:,2:4)=sublat_list(:,2:4)..
        +repmat(r_uc,tot_list,1);

        sublat_list(:,5:7)=sublat_list(:,5:7)..
        +repmat(r_uc*lat_vec,tot_list,1)

        r_diff=zeros(tot_list,4);
        r_diff(:,1:3)=sublat_list(:,5:7)-repmat(r_in,tot_list,1)
        for n=1:3
            r_diff(:,4)=r_diff(:,4)+r_diff(:,n).^2;
        end
        r_diff(:,4)=sqrt(r_diff(:,4));
        [val,ind]=min(r_diff(:,4))
        r_out=sublat_list(ind,1:4);
        norm_err=val;
        if dist_toler~=[] then
            if norm_err > dist_toler
                disp('Error: PIL_lat_index, norm_err > dist_toler!');
                abort
            end
        end
    case 4 // r_out=position vector
        r_out=zeros(1,3);
        r_out=sublat(r_in(1),:)+r_in(2:4)*lat_vec
        norm_err=0
    end
endfunction

// example
//r_in=10*[ 0.6502795    0.0881335    0.4498763]
//lat_vec=..
//[ 6.300000    0.000000    0.000000
//4.440000    4.480000    0.000000
//-5.370000   -2.240000    2.430000]
//sublat=..
//[0.000000    0.000000    0.000000
//3.150000    0.000000    1.215000
//4.478580    1.868160    0.000000
//1.328580    1.868160    1.215000]
//dist_toler=1.0
// 
// result:
// r_out=[1 2 1 2]
// norm_err=0.9738426
